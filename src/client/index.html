<!doctype html>
<meta charset="utf-8">
<meta name="referrer" content="no-referrer">
<meta name="viewport" content="height=device-height,width=device-width,minimum-scale=1,maximum-scale=1,initial-scale=1,user-scalable=no">

<meta name="color-scheme" content="light dark">
<meta name="theme-color" content="#FFFFFF">

<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text x='50%' y='50%' style='dominant-baseline:central;text-anchor:middle;font-size:100px;'>üì°</text></svg>">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/vuetify@3/dist/vuetify.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@7/css/materialdesignicons.min.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=M+PLUS+1+Code:wght@100;200;300;400;500;600;700">

<script type="importmap">
    {
        "imports": {
            "vue": "https://cdn.jsdelivr.net/npm/vue@3/dist/vue.esm-browser.prod.min.js"
        }
    }
</script>

<script async type="module">
    import {createApp, defineComponent, ref, reactive, inject, onMounted} from "https://cdn.jsdelivr.net/npm/vue@3/dist/vue.esm-browser.prod.min.js";
    import {createVuetify} from "https://cdn.jsdelivr.net/npm/vuetify@3/dist/vuetify.esm.min.js";

    import {fetchExtend, base64Encode} from "https://esm.sh/gh/dojyorin/deno_simple_utility@v1.0.0/mod.universal.ts?bundle&target=esnext";

    async function fetchAPI(path, type, body){
        return await fetchExtend(path, type, {
            method: body ? "POST" : "GET",
            body: body && JSON.stringify(body),
            headers: {
                ...body && {
                    "Content-Type": "application/json"
                }
            }
        });
    }

    function displayContent(own, type, value){
        const [h, m] = new Date().toLocaleTimeString().split(/:/);

        return {
            time: `${h}:${m}`,
            own: own,
            type: type,
            value: value
        };
    }

    function blobURL(data, mime){
        return URL.createObjectURL(new Blob([data], {
            type: mime
        }));
    }

    const sfc_layout_header = defineComponent({
        template: /*html*/`
            <v-app-bar density="compact" color="secondary">
                <v-spacer></v-spacer>
                <v-app-bar-title class="ml-0 text-center">OpenAI API Example</v-app-bar-title>
                <v-spacer></v-spacer>
            </v-app-bar>
        `
    });

    const sfc_layout_footer = defineComponent({
        template: /*html*/`
            <v-footer app class="px-3" color="grey-lighten-3">
                <v-btn-toggle mandatory density="comfortable" color="primary" v-model="type">
                    <v-btn icon="mdi-message-text-outline" value="chat"></v-btn>
                    <v-btn icon="mdi-image-outline" value="image"></v-btn>
                </v-btn-toggle>

                <v-textarea no-resize hide-details single-line flat clearable density="compact" variant="solo" rows="1" class="mx-3" label="„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ (Alt+Enter„ÅßÈÄÅ‰ø°)" @keyup.alt.enter.exact="requestApi()" v-model="input"></v-textarea>

                <v-btn flat density="comfortable" color="transparent" icon="mdi-send" @click="requestApi()"></v-btn>
            </v-footer>
        `,
        setup(){
            const loading = inject("xg-loading");
            const notifies = inject("xg-notifies");
            const threads = inject("xg-threads");

            const input = ref("");
            const type = ref("chat");

            async function requestApi(){
                const inputValue = input.value;

                if(!inputValue){
                    return;
                }

                threads.push(displayContent(true, "text", inputValue));

                input.value = "";

                try{
                    switch(type.value){
                        case "chat": {
                            const result = await fetchAPI("/chat", "text", {
                                query: inputValue
                            });

                            threads.push(displayContent(false, "text", result));
                        } break;

                        case "image": {
                            const result = await fetchAPI("/image", "byte", {
                                query: inputValue
                            });

                            threads.push(displayContent(false, "picture", blobURL(result, "image/png")));
                        } break;

                        default: break;
                    }
                }
                catch(e){
                    console.error(e);

                    notifies.push({
                        color: "error",
                        message: "ÈÄö‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü"
                    });
                }
            }

            return {input, type, requestApi};
        }
    });

    const sfc_layout_loading = defineComponent({
        template: /*html*/`
            <v-overlay persistent no-click-animation z-index="3000" class="justify-center align-center" v-model="loading">
                <v-progress-circular indeterminate size="60" width="4" color="primary"></v-progress-circular>
            </v-overlay>
        `,
        setup(){
            const loading = inject("xg-loading");

            return {loading};
        }
    });

    const sfc_layout_notify = defineComponent({
        template: /*html*/`
            <v-snackbar v-for="notify in notifies" model-value position="fixed" location="top" z-index="2100" :color="notify.color" timeout="-1" v-bind="notifyTimeout(notify, 5000)">
                <span>{{notify.message}}</span>

                <template #actions>
                    <v-btn ripple density="comfortable" icon="mdi-close" @click="notifyTimeout(notify, 0)"></v-btn>
                </template>
            </v-snackbar>
        `,
        setup(){
            const notifies = inject("xg-notifies");

            async function notifyTimeout(notify, ms){
                await new Promise(done => setTimeout(done, ms));

                const i = notifies.findIndex(v => v === notify);

                if(i === -1){
                    return;
                }

                notifies.splice(i, 1);
            }

            return {notifies, notifyTimeout};
        }
    });

    const sfc_page = defineComponent({
        template: /*html*/`
            <v-container>
                <v-list>
                    <v-list-item v-for="{time, own, type, value} in threads" class="mb-8">
                        <div class="d-flex" :style="own ? 'margin-left:40%' : 'margin-right:40%'" :class="own ? 'justify-end' : 'justify-start'">
                            <v-card v-if="own" flat class="d-flex align-end w-100">
                                <v-card-text class="px-2 py-0">{{time}}</v-card-text>
                            </v-card>

                            <v-card flat rounded="lg" variant="tonal" :color="own ? 'deep-purple-accent-4' : 'orange-darken-4'">
                                <v-card-text v-if="type === 'text'" class="text-body-1 text-pre-wrap">{{value}}</v-card-text>
                                <v-img v-else-if="type === 'picture'" :src="value" width="256"></v-img>
                            </v-card>

                            <v-card v-if="!own" flat class="d-flex align-end w-100">
                                <v-card-text class="px-2 py-0">{{time}}</v-card-text>
                            </v-card>
                        </div>
                    </v-list-item>
                </v-list>
            </v-container>
        `,
        setup(){
            const threads = inject("xg-threads");

            return {threads};
        }
    });

    const sfc_main = defineComponent({
        template: /*html*/`
            <v-app>
                <x-loading></x-loading>
                <x-notify></x-notify>

                <x-header></x-header>

                <v-main>
                    <x-page></x-page>
                </v-main>

                <x-footer></x-footer>
            </v-app>
        `,
        components: {
            "x-header": sfc_layout_header,
            "x-footer": sfc_layout_footer,
            "x-loading": sfc_layout_loading,
            "x-notify": sfc_layout_notify,
            "x-page": sfc_page
        },
        setup(){
            const loading = inject("xg-loading");

            onMounted(()=>{
                loading.value = false;
            });

            return {};
        }
    });

    const vuetify = createVuetify({
        theme: {
            defaultTheme: "main-light",
            themes: {
                "main-light": {
                    dark: false,
                    colors: {
                        primary: "#03A9F4",
                        secondary: "#9C27B0",
                        surface: "#FFFFFF",
                        background: "#FFFFFF",
                        info: "#2196F3",
                        success: "#4CAF50",
                        warning: "#FFC107",
                        error: "#FF5252"
                    }
                }
            }
        }
    });

    const provide = ((arg)=>{
        return {
            install(context){
                for(const [k, v] of Object.entries(arg)){
                    context.provide(k, v);
                }
            }
        };
    })({
        "xg-loading": ref(false),
        "xg-notifies": reactive([]),
        "xg-threads": reactive([])
    });

    const vue = createApp(sfc_main);

    vue.use(vuetify);
    vue.use(provide);

    vue.mount("#vue");
</script>

<style>
    ::-webkit-scrollbar {
        display: none !important;
    }

    :focus {
        outline: none !important;
    }

    * {
        font-family: "M PLUS 1 Code" !important;
    }

    .v-btn {
        text-transform: none !important;
        letter-spacing: normal !important;
        text-indent: 0 !important;
    }
</style>

<title>OpenAI API Example</title>

<div id="vue"></div>